% \iffalse meta-comment
% !TEX program  = pdfLaTeX
%
% Copyright (C) 2021 by James Cooper, University of Auckland <jcoo092@aucklanduni.ac.nz>
% ---------------------------------------------------------------------------
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is James Cooper, University of Auckland.
%
% This work consists of the files cpsystems.dtx and cpsystems.ins
% and the derived filebase cpsystems.sty, cpsystems.pdf and README.txt.
%
% \fi
% \iffalse
%<*readme>
%%cpsystems LaTeX package
%%Copyright (C) 2021 by James Cooper, University of Auckland <jcoo092@aucklanduni.ac.nz>
%%
%%The goal of this work is to provide a self-contained, easy-to-use LaTeX package that eases the typesetting of cP systems, a variant of Membrane Computing/P systems created by Dr. Radu Nicolescu and collaborators in the early 2010s.  Please refer to the package documentation for instructions on its use.  To the best of my knowledge, it is compatible with all LaTeX2e distributions which are reasonably up-to-date, as well as all classes (and likely all or almost all packages) that are typically used for publishing material on P systems.
%%
%%For more on cP systems, please see for example:  Nicolescu, R., & Henderson, A. (2018). An Introduction to cP Systems. In C. Graciani, A. Riscos-Núñez, G. Păun, G. Rozenberg, & A. Salomaa (Eds.), Enjoying Natural Computing: Essays Dedicated to Mario de Jesús Pérez-Jiménez on the Occasion of His 70th Birthday (pp. 204–227). https://doi.org/10.1007/978-3-030-00265-7_17
%%
%%This work consists of the file cpsystems.dtx, cpsystems.ins and their derived products cpsystems.sty, cpsystems.pdf and this README.  The `canonical' version of this work is currently to be found at https://github.com/jcoo092/LaTeX-cP-systems/ 
%%
%%Constructive pull requests, creation of issues for bugs, and suggestions for improvements are very welcome.
%%
%%This package was originally created to assist me while writing a paper on cP systems which also largely re-appears in my PhD dissertation.  While you are certainly free to peruse and use this package, if you don't know what Membrane Computing/P systems is, this package is unlikely to be of much use to you.
%</readme>
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{cpsystems.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[2011/06/27]
%<package>\ProvidesPackage{cpsystems}
%<*package>
[2021/08/11 v0.19 Package to aid in typesetting cP systems 
	rulesets, following Nicolescu's standard style]
%</package>
%
%<*driver>
\documentclass{ltxdoc}
\usepackage{cpsystems}[2021/08/11 v0.19]
\usepackage{fancyvrb}
\usepackage[hidelinks]{hyperref}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
%\OnlyDescription %Leave this commented out unless you have read the Doc documentation and know what you're doing
\begin{document}
  \DocInput{cpsystems.dtx}
  \PrintIndex
  \PrintChanges
\end{document}
%</driver>
% \fi
%
% \changes{0.19}{2021/08/11}{Most importantly, changed the default behaviour of rules numbers --- now, they no longer continue on from one ruleset to the next by default.  Instead, they reset at each new \texttt{cprulesetfloat}.  Added commands for the \texttt{cpfuncn} and \texttt{cpfuncnms} stuff.  Modified the \texttt{cprule} definition to permit the optional width adjustment.  Introduced the (basically untested) \texttt{cprulsetcontnum} environment, and the \texttt{cpdiscard} command.  Also added in the internal \texttt{perfunXXX} macros to tidy up the definitions of other macros.}
% \changes{0.18}{2021/07/14}{Added in \texttt{cprulecustnum}, \texttt{cpantirecv}, \texttt{cpantisend}, \texttt{cptuple}, \texttt{cptupetemplate}, \texttt{cponce}, \texttt{cpmaxpar}, \texttt{cpset}.  Adjusted the arraystretch for rules slightly (from 1.0 to 1.1).   Prefixed \texttt{changerulenumber} and \texttt{resetrulenumber} with \texttt{cp}.  }
% \changes{0.17}{2021/03/17}{Remove the ending dot from \texttt{cpterm}.  Adjust \texttt{cpsend} and \texttt{cprecv} to use a single internal base rule.  Removed the \texttt{cps} command, to avoid potential conflicts with other packages.  I have found defining cP systems as a glossary term to be a superior alternative anyway.  Changed \texttt{cpresetrulenumber} to make use of \texttt{cpchangerulenumber}, instead of replicating the functionality.}
% \changes{0.16}{2020/12/28}{Added in the \texttt{cpruleinline} and \texttt{cpfuncms} macros, since I had already created them and am using them in a paper I am writing.}
% \changes{0.15}{2020/12/27}{Introduced use of perfectcut to provide automatically-resizing brackets.  Also added an explanation and example for \texttt{cpterm}.  Unfortunately, this also breaks linebreaks inside \texttt{cpfunc} macros for the time being...}
% \changes{0.14}{2020/12/27}{Add minimum LaTeX2e version to package specification.  Change many of the \texttt{newcommand} declarations to use the \texttt{newcommand*} style, making them ``short commands'', which (apparently) throw warnings if there is a paragraph break detected in their use -- the ones modified aren't expected to have paragraph breaks in them.  Also, added in the \texttt{cps}, \texttt{cpundig} and \texttt{cpempty} convenience macros.}  
% \changes{0.13.1}{2020/01/12}{Fix problem with arrows appearing in the \texttt{cppromoter} and \texttt{cpinhibitor} results.}
% \changes{0.13}{2020/01/04}{Added in the commands for \texttt{cprulenonum}, \texttt{changerulenum} and \texttt{resetrulenum}.  Modified the four major pre-existing rule typesetting macros all to use an internal macro, reducing duplication of code.  Also corrected a handful of typos in the document.}
% \changes{0.12}{2019/12/31}{Completed documentation for first DTX format attempt}
% \changes{0.11}{2019/12/27}{Converted to DTX file}
%
% \DoNotIndex{\[, \{, \], \}, \\, \_}
%
% \DoNotIndex{\arabic, \arraystretch, \begin, \big, \DeclareFloatingEnvironment, \end, \hspace, \item, \NeedsTeXFormat, \neg, \newcommand, \newcounter, \setcounter,
%	\newenvironment, \ProvidesPackage, \refstepcounter, \renewcommand, \RequirePackage, \rightarrow, \trim@spaces@noexp, \mathit, \lambda, \perfectunary, \Pi, \scriptstyle,
%	\value, \Bar}
%
% \providecommand*{\url}{\texttt}
% \GetFileInfo{cpsystems.dtx}
% \title{The \textsf{cpsystems} \LaTeX{} package \\ \footnotesize{\url{https://github.com/jcoo092/LaTeX-cP-systems}}}
% \author{James Cooper, University of Auckland \\ \footnotesize{\url{jcoo092@aucklanduni.ac.nz}}}
% \date{\fileversion, \filedate}
%
% \maketitle
% 
% \VerbatimFootnotes
%
% \begin{abstract}
%	A package to assist authors writing about cP~systems with typesetting their papers.  It comprises a handful of environments and macros that are intended to ease writing about cP~systems, and just as importantly, reduce the frequency of errors in the presentation.  It is recommended to all authors using \LaTeX{} to write about cP~systems.  Even if you don't want to use it, looking at the implementation details may give you some ideas for your own style.
% \end{abstract}
% 
% \tableofcontents
% 
% \newpage
%
% \section{Introduction}
% This is a package to assist authors in writing papers on cP~systems, a particular variant of P~systems that was created by Dr. Radu Nicolescu, along with a number of collaborators, in the early 2010s.  This document assumes you have a working knowledge of cP~systems and how they should look when fully typeset.  It makes no attempt to explain the theory of cP~systems, nor why they are set out in the fashion that they are.  If you would like further information on cP~systems, please see \cite{Nicolescu2018}, or \cite{Paun2002} for an excellent (albeit somewhat old) introduction to P~systems generally.
% 
% This package was originally created by James Cooper to help with typesetting a specific paper on cP~systems (specifically one about modelling Belief Propagation in cP~systems).  The same commands had historically been copied from paper to paper, and across sections within papers, as most of them weren't even formed into proper \LaTeX{} macros.  This was, of course, extremely error prone, with formatting errors (and worse) sometimes making it into published articles.  The commands in this package in many cases are no less verbose than simply typing out the commands inside the macros.  They are more `robust'\footnote{Note that \LaTeX{} has its own, different, concept of ``robust''.}, however, in that by using the defined macros the exact same commands are applied each time so there is greater consistency throughout the paper.\footnote{It is also hoped, perhaps vainly, that this package could eventually become \emph{the} standard way to set out cP~systems, assuring consistency across different papers by different authors.}  If the macro is mistyped, the \LaTeX{} engine itself will report the error.  They also hopefully should add greater structure to a paper and prove useful in editing the paper.
% 
% Note that, at present, this package is \emph{not} available on CTAN, and instead may only be retrieved from the author's academic GitHub account (see the URL listed in this document's title).  Once it has been sufficiently developed and stabilised, and/or there is consistent demand for such a package beyond the author's immediate research group, it likely will be added to CTAN, but there is no timeframe nor guarantee in place for that.
%
% Also be aware that some of the commands included in the package aren't currently documented outside of section \ref{sec:implementation}.  The commands exist and are used, but I haven't had the spare time to write about them properly yet.
%
% \section{Usage}
%
% This section firstly gives a brief overview of the individual usage of each command, and then supplies a few examples showing their combined use.  For the full examples, the verbatim \LaTeX{} code needed to typeset the corresponding example in each instance is bounded at the top and bottom by horizontal lines, to try to make it more clear where an example starts and ends.  It is the case, however, that sometimes floating environments interrupt them.
%
% \subsection{Environments}
% 
% \subsubsection{Floats}
%
% \DescribeEnv{cprulesetfloat}
% Container for a |cpruleset|.  The |cprulesetfloat| wraps a |cpruleset| and provides it with the capability to float in the document, in much the same fashion as image and tables typically do.  It also provides the ability to caption the environment, and provide it with a label for cross-referencing purposes.  These latter are done in the exact same way as with an \Verb+\includegraphics{}+ environment from the \texttt{graphicx} package.  Furthermore, it works with the \texttt{hyperref} package's \Verb+\autoref{}+ command, supplying the environment's number, and the name `Ruleset'.
% 
% \noindent
% \DescribeEnv{cpobjectsfloat}
% Container for a |cpobjects|.  The |cpobjectsfloat| wraps a |cpobjects| and provides it with the capability to float in the document, in much the same fashion as image and tables typically do.  It also provides the ability to caption the environment, and provide it with a label for cross-referencing purposes.  These latter are done in the exact same way as with an \Verb+\includegraphics{}+ environment from the \texttt{graphicx} package.  Furthermore, it works with the \texttt{hyperref} package's \Verb+\autoref{}+ command, supplying the environment's number, and the name `Objects Group'.
% 
% \subsubsection{Maths environment floats}
% 
% \noindent
% \DescribeEnv{cpruleset}
%  Goes inside a |cprulesetfloat|.  This provides the surrounding environment that |cprule|s, |cppromoter|s and |cpinhibitor|s are written inside.  It ensures that the appropriate maths mode is active inside itself, as well as providing the array structure that the rules are set inside and drawing a box around the whole thing.  Note that the text and box can become misaligned if they bump into the edge of a page.  It seems to be common for the box to break over the two pages and stay inside the usual margins, but the text just carries on as it pleases, going right outside the margins.  For this reason, as well as the aforementioned benefits, it is strongly recommended that you always place a |cpruleset| inside a |cprulesetfloat|.
%  
% \noindent
% \DescribeEnv{cpobjects}
% Goes inside a |cpobjectsfloat|.  This provides the surrounding environment that |cpobjectline|s are written inside.  It ensures that the appropriate maths mode is active inside itself, as well as drawing a box around the whole thing.  Note that the text and box can become misaligned if they bump into the edge of a page.  It seems to be common for the box to break over the two pages and stay inside the usual margins, but the text just carries on as it pleases, going right outside the margins.  For this reason, as well as the aforementioned benefits, it is strongly recommended that you always place a |cpobjects| inside a |cpobjectsfloat|.
%
% \subsection{Macros}
% 
% Brief descriptions of the rules and their use are provided here for reference purposes, but it is recommended that you take a look at \autoref{sect:fulleg} for examples on how to use them properly.
% 
% \subsubsection{Rules}
%
% \noindent
% \DescribeMacro{\cprule}
% |\cprule| \marg{Starting state} \marg{Input objects} \marg{Mode of operation} \marg{Ending state} \marg{Output objects}
% 
% Goes inside a |cpruleset| environment.  This is used to write out individual rules, and takes five mandatory arguments.  They are, in order, the starting state for the rule; the set of objects that are matched on and consumed by the rule; the parallelism mode specifier (currently \(+\) and \(1\) are standard for maximum and minimum parallelism); the ending state for the rule;  the objects that are output at the end of the rule.
% 
% E.g. a rule to move a single \(a\) out of a \(b\) functor might be written like:\\ \Verb+\cprule{s_1}{b(aa)}{1}{s_1}{b(a)~a}+ 
%
% \noindent
% \DescribeMacro{\cpruleinline}
% |\cprule| \marg{Contained |cprulenonum|}
% 
% Substitute for the |cpruleset| environment when the full environment is unwanted, and instead one simply wishes to include a single rule in the normal text.  This macro takes a single input, a |cprulenonum| macro, which specifies the actual rule to be typeset.  Despite its name, this macro still sets the rule out in its own mini-paragraph because it uses the standalone mathematics delimiters internally.
% 
% E.g. a rule to move a single \(a\) out of a \(b\) functor might be written inline in the text like:\\ \Verb+\cpruleinline{\cprulenonum{s_1}{b(aa)}{1}{s_1}{b(a)~a}}+ 
% 
% \noindent
% \DescribeMacro{\cprulenonum}
% |\cprule| \marg{Starting state} \marg{Input objects} \marg{Mode of operation} \marg{Ending state} \marg{Output objects}
% 
% Goes inside a |cpruleset| environment.  Identical to a |\cprule|, except that this version neither shows a rule number, nor increments the rule counter.
%
% \noindent
% \DescribeMacro{\cppromoter}
% |\cppromoter| \marg{The promoting cP~systems object}
% 
% Goes immediately beneath a |cprule|, |cpinhibitor| or another |cppromoter|.  This command takes a single argument, which is the term(s) to be written out as a promoter for a rule.
%
% \noindent
% \DescribeMacro{\cpinhibitor}
% |\cpinhibitor| \marg{The inhibiting cP~systems object}
% 
% Goes immediately beneath a |cprule|, |cpinhibitor| or another |cppromoter|.  This command takes a single argument, which is the term(s) to be written out as a inhibitor for a rule.
%
% \noindent
% \DescribeMacro{\cpsend}
% |\cpsend| \marg{The object(s) to be sent} \marg{The name of the channel over which to send the object(s)}
% 
% Goes inside a |cprule|.  This is as a convenience for writing out parts of rules where one or more objects are sent over a channel.  This macro abstracts over the slightly fiddly details of writing it out.  This command takes two arguments.  The first is the object(s) to be sent, and the second is the name of the channel (as it appears to the current top-level cell) the object(s) are to be sent over.
%
% \noindent
% \DescribeMacro{\cprecv}
% |\cprecv| \marg{The pattern of the object(s) to be received} \marg{The name of the channel over which to receive the object(s)}
% 
% Goes inside a |cprule|.  This is as a convenience for writing out parts of rules where one or more objects are received over a channel.  This macro abstracts over the slightly fiddly details of writing it out.  This command takes two arguments.  The first is the object(s) to be received, and the second is the name of the channel (as it appears to the current top-level cell) the object(s) are to be received over.
% 
% Note, of course, that if an object is sent to the current top-level either using a non-existent channel or a pattern that is not specified by any receiving rule in the system, that object will not be retrieved from the channel by the current top-level cell.
% 
% \noindent
% \DescribeMacro{\changerulenum}
% |\changerulenum| \marg{The number to which you would like to set the rule counter}
% 
% Set the rules counter to whatever number you prefer.
% 
% \noindent
% \DescribeMacro{\resetrulenum}
% |\resetrulenum|
% 
% Resets the rules counter back to zero, which means that the next time you use a |\cprule|, that rule will receive the number 1.
%  
%  \subsubsection{Objects}
%
% \noindent
% \DescribeMacro{\cpobjectsline}
% |\cpobjectsline| \marg{cP~systems objects to be presented as contained within that particular top-level cell}
% 
% Goes inside a |cpobjects| environment.  Used to set out a full line of inert objects that will be inside a top-level cell.  Note that, despite what one may initially assume, there is \emph{no} included ability (currently) for this to re-flow objects across lines.  It is up to the author to break up their listing of objects appropriately into separate lines.
% 
% \subsubsection{Miscellaneous}
%
% \noindent
% \DescribeMacro{\cpfunc}
% |\cpfunc| \marg{Outer functor} \marg{Contents of functor}
% 
% Typically used inside a |cprule|, though so long as it is used inside a maths mode environment of some sort (e.g. \Verb+\(\_\)+ or\Verb+\ensuremath{}+) it should still work.  This command is used to write out a functor and its contents, where the first argument is the name of the containing functor and the second argument is everything that is contained inside the functor.  They can, of course, be nested -- in fact, this is encouraged.  The implementation of |cpfunc| \emph{should} ensure that the brackets will scale appropriately automatically, so that outer functors have larger brackets than inner ones.
%
% Line breaking is currently, er, broken in this implementation.  It didn't play well with the auto-growing brackets.  |\\| is completely unusable inside a |cpfunc|.  |\linebreak| and |\newline| can be included, but seem to do absolutely nothing.  If you have any |&|s for marking out columns, they seem to cause compilation errors and should be removed.  It is unclear at the moment how to restore this functionality, but this issue is why the examples below all spill well past the right-hand-side of their frames.
%
% \noindent
% \DescribeMacro{\cpfuncms}
% |\cpfuncms| \marg{Outer functor} \marg{Contents of functor}
% 
% Exactly the same as a regular |cpfunc| except this one is for functors subject to micro-surgeries, and so uses curly braces instead of parentheses.  It uses curly braces because currently that is the correct style for typesetting micro-surgeries.  That is potentially subject to change in the future, so you should probably opt to use this macro instead of doing it by hand, to save yourself some hassle if/when the style does change.  Moreover, using this macro means that you get auto-growing brackets with micro-surgery functors as well as regular ones.
%
% \noindent
% \DescribeMacro{\cpterm}
% This command is used to explain the meaning of a given cP systems term/symbol.  E.g. if you have a functor such as \(a(b)\), you might use |\cpterm| entries to explain the meanings of both the \(a\) functor and \(b\) atom.  Note that the current implementation of this command automatically includes a full stop/period at the end of the description -- so if you include one inside the description, you will get a double dot.  It is generally recommended to encapsulate these definitions inside a |description| environment, which ends up with everything set out pretty well.  Further, separating out the atoms from the functors from the states is also recommended.  So far, using a |paragraph| command to give the relevant title to each one, followed by a |description| with the |cpterm|s inside that seems to work out pretty well.
%
% \noindent
% \DescribeMacro{\cpundig}
% |\cpundig|
% A parameter-less convenience macro for inserting the correctly-formatted cP~systems `unitary digit' in rules.
%
% \noindent
% \DescribeMacro{\cpempty}
% |\cpempty|
% A parameter-less convenience macro for inserting the correctly-formatted empty functor symbol (which is actually just a |\lambda|).  Mostly used so that intent is clear in the rules specifications, but also partly in case someone ends up changing how empty functors are specified.
% 
% 
% \subsection{\label{sect:fulleg}Full examples}
% 
% \subsubsection{A floating cP~systems ruleset}
% 
% For example, to typeset the ruleset for the solution to the Travelling Salesman Problem in \cite{Cooper2019}, depicted here in \autoref{rules:TSP}, the following was used:\footnote{The reference to the given label was in turn created using \verb+\autoref{rules:TSP}+, with \texttt{autoref} coming from the \texttt{hyperref} package.}
% 
% \begin{Verbatim}[gobble=1,frame=lines,labelposition=topline,label=Code to produce \autoref{rules:TSP},tabsize=2]
% \begin{cprulesetfloat}
% 	\begin{cpruleset}
% 		\cprule{s_1}{\cpfunc{v}{v(R)Y}}{1}{s_2}{\cpfunc{s}{r(R)~u(Y)~
% 		\cpfunc{p}{h(R)p()}}~c(\lambda)}
% 		
% 		\cprule{s_2}{\cpfunc{s}{r(R)~u()~\cpfunc{p}{h(F)p(P)}~c(C)}}
% 		{+}{s_3}{\cpfunc{z}{\cpfunc{p}{h(R) \cpfunc{p}{h(F)p(P)}}}~c(W)}
% 		\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%		
%		\cprule{s_2}{}{+}{s_2}{\cpfunc{s}{r(R)~u(Z)~
%		\cpfunc{p}{h(T) \cpfunc{p}{h(F) p(P)}}~c(CW)}}
%		\cppromoter{\cpfunc{s}{r(R)~\cpfunc{u}{v(T)Z}~
%		\cpfunc{p}{h(F) p(P)}~c(C)}}
%		\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%		
%		\cprule{s_2}{s(\_)}{+}{s_2}{}
%		
%		\cprule{s_3}{}{1}{s_4}{p'(P) \quad c'(1D)}
%		\cppromoter{\cpfunc{z}{p(P~c(1D)}}
%		\cpinhibitor{(D = CW)~\cpfunc{z}{p(\_)~c(C)}}
% 	
% 	 \end{cpruleset}
% 	 \caption{\label{rules:TSP} The five rules from \cite{Cooper2019},
% 	  updated to the latest (at the time of writing) style for cP~systems.}
% \end{cprulesetfloat}
% \end{Verbatim}
% 
%  \begin{cprulesetfloat}
% 	\begin{cpruleset}
% 		\cprule{s_1}{\cpfunc{v}{v(R)Y}}{1}{s_2}{\cpfunc{s}{r(R)~u(Y)~
% 		\cpfunc{p}{h(R)p()}}~c(\lambda)}
% 		
% 		\cprule{s_2}{\cpfunc{s}{r(R)~u()~\cpfunc{p}{h(F)p(P)}~c(C)}}
% 		{+}{s_3}{\cpfunc{z}{\cpfunc{p}{h(R) \cpfunc{p}{h(F)p(P)}}}~c(W)}
% 		\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%		
%		\cprule{s_2}{}{+}{s_2}{\cpfunc{s}{r(R)~u(Z)~
%		\cpfunc{p}{h(T) \cpfunc{p}{h(F) p(P)}}~c(CW)}}
%		\cppromoter{\cpfunc{s}{r(R)~\cpfunc{u}{v(T)Z}~
%		\cpfunc{p}{h(F) p(P)}~c(C)}}
%		\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%		
%		\cprule{s_2}{s(\_)}{+}{s_2}{}
%		
%		\cprule{s_3}{}{1}{s_4}{p'(P) \quad c'(1D)}
%		\cppromoter{\cpfunc{z}{p(P~c(1D)}}
%		\cpinhibitor{(D = CW)~\cpfunc{z}{p(\_)~c(C)}}
%
% 	\end{cpruleset}
% 	\caption{\label{rules:TSP} The five rules from \cite{Cooper2019},
% 	 updated to the latest (at the time of writing) style for cP~systems.}
% \end{cprulesetfloat}
% 
% There is, however, an extremely obvious problem with \autoref{rules:TSP} -- much of it extends beyond the box.  That is partly a product of the narrow margins for the main text body of the current document class, but with rules of any real length this is an inevitability really, if the entire thing is set onto a single line.  The solution, therefore, is to split the wider parts over multiple lines, thereby permitting the array to narrow each individual field, and thus fit everything inside the box.  Unfortunately, at present there is no \emph{good} way to do this.  The way to achieve it is simply to include a line break (i.e. \Verb+\\+) and then an appropriate number of ampersands (\&) to bring the array back into alignment, as demonstrated in \autoref{rules:TSP2}.  It is important (and sometimes slightly tricky) to get the number of ampersands exactly correct.  The wrong number can either lead to errors from the \LaTeX{} compiler and/or part of a rule appearing in a different column to the intended one.
% 
% \begin{Verbatim}[gobble=1,frame=lines,labelposition=topline,label=Code to produce \autoref{rules:TSP2},tabsize=2]
% \begin{cprulesetfloat}
% 	\begin{cpruleset}
% 		\cprule{s_1}{\cpfunc{v}{v(R)Y}}{1}{s_2}{\cpfunc{s}{r(R)~u(Y)~
% 		\cpfunc{p}{h(R)p()}}~c(\lambda)}
% 		
% 		\cprule{s_2}{\cpfunc{s}{r(R)~u() \newline \cpfunc{p}{h(F)p(P)} \newline c(C)}}
% 		{+}{s_3}{\cpfunc{z}{\cpfunc{p}{h(R) \cpfunc{p}{h(F)p(P)}}}~c(W)}
% 		\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%		
%		\cprule{s_2}{}{+}{s_2}{\cpfunc{s}{r(R)~u(Z) \newline
%		 \cpfunc{p}{h(T) \cpfunc{p}{h(F) p(P)}}
%		\newline  c(CW)}}
%		\cppromoter{\cpfunc{s}{r(R)~\cpfunc{u}{v(T)Z}~
%		\cpfunc{p}{h(F) p(P)}~c(C)}}
%		\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%		
%		\cprule{s_2}{s(\_)}{+}{s_2}{}
%		
%		\cprule{s_3}{}{1}{s_4}{p'(P) \quad c'(1D)}
%		\cppromoter{\cpfunc{z}{p(P~c(1D)}}
%		\cpinhibitor{(D = CW)~\cpfunc{z}{p(\_)~c(C)}}
% 
% 	\end{cpruleset}
% 	\caption{\label{rules:TSP2} The five rules from \cite{Cooper2019},
% 	 updated to the latest (at the time of writing) style for cP~systems
% 	  -- rewritten to make it fit inside the box.}
% \end{cprulesetfloat}
% \end{Verbatim}
% 
% \begin{cprulesetfloat}
% 	\begin{cpruleset}
% 		\cprule{s_1}{\cpfunc{v}{v(R)Y}}{1}{s_2}{\cpfunc{s}{r(R)~u(Y)~
% 		\cpfunc{p}{h(R)p()}}~c(\lambda)}
% 		
% 		\cprule{s_2}{\cpfunc{s}{r(R)~u() \newline \cpfunc{p}{h(F)p(P)} \newline c(C)}}
% 		{+}{s_3}{\cpfunc{z}{\cpfunc{p}{h(R) \cpfunc{p}{h(F)p(P)}}}~c(W)}
% 		\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%		
%		\cprule{s_2}{}{+}{s_2}{\cpfunc{s}{r(R)~u(Z) \newline
%		 \cpfunc{p}{h(T) \cpfunc{p}{h(F) p(P)}}
%		\newline  c(CW)}}
%		\cppromoter{\cpfunc{s}{r(R)~\cpfunc{u}{v(T)Z}~
%		\cpfunc{p}{h(F) p(P)}~c(C)}}
%		\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%		
%		\cprule{s_2}{s(\_)}{+}{s_2}{}
%		
%		\cprule{s_3}{}{1}{s_4}{p'(P) \quad c'(1D)}
%		\cppromoter{\cpfunc{z}{p(P~c(1D)}}
%		\cpinhibitor{(D = CW)~\cpfunc{z}{p(\_)~c(C)}}
%
% 	\end{cpruleset}
% 	\caption{\label{rules:TSP2} The five rules from \cite{Cooper2019},
% 	 updated to the latest (at the time of writing) style for cP~systems
% 	  -- rewritten to make it fit inside the box.}
% \end{cprulesetfloat}
% 
% Notice that the numbering of the rules in \autoref{rules:TSP2} \emph{does not} carry on from those in the previous |cprulesetfloat|, \autoref{rules:TSP}.  This is different from the behaviour before version 0.19, where the rules did continue on by default.  Generally speaking, this is the desired behaviour.  If you do want rules to carry on from earlier, try out the |cprulesetcontnum| environment.  Let's give it a looksee now.  Check out \autoref{rules:TSP3}.
% 
% \begin{Verbatim}[gobble=1,frame=lines,labelposition=topline,label=Code to produce \autoref{rules:TSP3},tabsize=2]
% \begin{cprulesetfloat}
% 	\begin{cprulesetcontnum}
% 		\cprule{s_1}{\cpfunc{v}{v(R)Y}}{1}{s_2}{\cpfunc{s}{r(R)~u(Y)~
% 		\cpfunc{p}{h(R)p()}}~c(\lambda)}
% 		
% 		\cprule{s_2}{\cpfunc{s}{r(R)~u() \newline \cpfunc{p}{h(F)p(P)} \newline c(C)}}
% 		{+}{s_3}{\cpfunc{z}{\cpfunc{p}{h(R) \cpfunc{p}{h(F)p(P)}}}~c(W)}
% 		\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%		
%		\cprule{s_2}{}{+}{s_2}{\cpfunc{s}{r(R)~u(Z) \newline
%		 \cpfunc{p}{h(T) \cpfunc{p}{h(F) p(P)}}
%		\newline  c(CW)}}
%		\cppromoter{\cpfunc{s}{r(R)~\cpfunc{u}{v(T)Z}~
%		\cpfunc{p}{h(F) p(P)}~c(C)}}
%		\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%		
%		\cprule{s_2}{s(\_)}{+}{s_2}{}
%		
%		\cprule{s_3}{}{1}{s_4}{p'(P) \quad c'(1D)}
%		\cppromoter{\cpfunc{z}{p(P~c(1D)}}
%		\cpinhibitor{(D = CW)~\cpfunc{z}{p(\_)~c(C)}}
% 
% 	\end{cprulesetcontnum}
% 	\caption{\label{rules:TSP3} The five rules from \cite{Cooper2019},
% 	 updated to the latest (at the time of writing) style for cP~systems
% 	  -- rewritten to make it fit inside the box.}
% \end{cprulesetfloat}
% \end{Verbatim}
% 
% \begin{cprulesetfloat}
% 	\begin{cprulesetcontnum}
% 		\cprule{s_1}{\cpfunc{v}{v(R)Y}}{1}{s_2}{\cpfunc{s}{r(R)~u(Y)~
% 		\cpfunc{p}{h(R)p()}}~c(\lambda)}
% 		
% 		\cprule{s_2}{\cpfunc{s}{r(R)~u() \newline \cpfunc{p}{h(F)p(P)} \newline c(C)}}
% 		{+}{s_3}{\cpfunc{z}{\cpfunc{p}{h(R) \cpfunc{p}{h(F)p(P)}}}~c(W)}
% 		\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%		
%		\cprule{s_2}{}{+}{s_2}{\cpfunc{s}{r(R)~u(Z) \newline
%		 \cpfunc{p}{h(T) \cpfunc{p}{h(F) p(P)}}
%		\newline  c(CW)}}
%		\cppromoter{\cpfunc{s}{r(R)~\cpfunc{u}{v(T)Z}~
%		\cpfunc{p}{h(F) p(P)}~c(C)}}
%		\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%		
%		\cprule{s_2}{s(\_)}{+}{s_2}{}
%		
%		\cprule{s_3}{}{1}{s_4}{p'(P) \quad c'(1D)}
%		\cppromoter{\cpfunc{z}{p(P~c(1D)}}
%		\cpinhibitor{(D = CW)~\cpfunc{z}{p(\_)~c(C)}}
%
% 	\end{cprulesetcontnum}
% 	\caption{\label{rules:TSP3} The five rules from \cite{Cooper2019},
% 	 updated to the latest (at the time of writing) style for cP~systems
% 	  -- rewritten to make it fit inside the box.}
% \end{cprulesetfloat}
% 
% \newpage This page has been left blank intentionally (excepting any floats that may end up here).  You'll see why in a moment.  \newpage \vspace*{0.1\textheight}
% 
% \subsubsection{A sinking ruleset}
% 
% If, for some reason, you \emph{don't} want your ruleset floating, or to have a caption or label, you dont actually need to use the |cprulesetfloat| environment.  |cpruleset| is all you need for laying out rules.  Just, the results probably won't be as good:
% 
% \begin{Verbatim}[gobble=1,frame=lines,labelposition=topline,label=Code to produce the unlabelled non-floating cpruleset,tabsize=2]
% \begin{cpruleset}
%	\cprule{s_1}{\cpfunc{v}{v(R)Y}}{1}{s_2}{\cpfunc{s}{r(R)~u(Y)~
%	\cpfunc{p}{h(R)p()}}~c(\lambda)}
%	
%	\cprule{s_2}{\cpfunc{s}{r(R)~u() \newline \cpfunc{p}{h(F)p(P)} \newline c(C)}}
%	{+}{s_3}{\cpfunc{z}{\cpfunc{p}{h(R) \cpfunc{p}{h(F)p(P)}}}~c(W)}
%	\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%
%	\cprule{s_2}{}{+}{s_2}{\cpfunc{s}{r(R)~u(Z) \newline
%	 \cpfunc{p}{h(T) \cpfunc{p}{h(F) p(P)}}
%	\newline c(CW)}}
%	\cppromoter{\cpfunc{s}{r(R)~\cpfunc{u}{v(T)Z}~
%	\cpfunc{p}{h(F) p(P)}~c(C)}}
%	\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%	
%	\cprule{s_2}{s(\_)}{+}{s_2}{}
%	
%	\cprule{s_3}{}{1}{s_4}{p'(P) \quad c'(1D)}
%	\cppromoter{\cpfunc{z}{p(P~c(1D)}}
%	\cpinhibitor{(D = CW)~\cpfunc{z}{p(\_)~c(C)}}
%
% \end{cpruleset}
% \end{Verbatim}
% 
%\begin{cpruleset}
%	\cprule{s_1}{\cpfunc{v}{v(R)Y}}{1}{s_2}{\cpfunc{s}{r(R)~u(Y)~
%	\cpfunc{p}{h(R)p()}}~c(\lambda)}
%	
%	\cprule{s_2}{\cpfunc{s}{r(R)~u() \newline \cpfunc{p}{h(F)p(P)} \newline c(C)}}
%	{+}{s_3}{\cpfunc{z}{\cpfunc{p}{h(R) \cpfunc{p}{h(F)p(P)}}}~c(W)}
%	\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%
%	\cprule{s_2}{}{+}{s_2}{\cpfunc{s}{r(R)~u(Z) \newline
%	 \cpfunc{p}{h(T) \cpfunc{p}{h(F) p(P)}}
%	\newline c(CW)}}
%	\cppromoter{\cpfunc{s}{r(R)~\cpfunc{u}{v(T)Z}~
%	\cpfunc{p}{h(F) p(P)}~c(C)}}
%	\cppromoter{\cpfunc{e}{f(F)~t(T)~c(W)}}
%	
%	\cprule{s_2}{s(\_)}{+}{s_2}{}
%	
%	\cprule{s_3}{}{1}{s_4}{p'(P) \quad c'(1D)}
%	\cppromoter{\cpfunc{z}{p(P~c(1D)}}
%	\cpinhibitor{(D = CW)~\cpfunc{z}{p(\_)~c(C)}}
%
% \end{cpruleset}
%
% This has been carefully constructed to reveal another problem with this approach.  Without the floating environment, the ruleset is printed essentially exactly where it was declared, with the box of the |cpruleset| mostly printing on one page, but breaking and starting again on the next, but the text contained inside the environment is shifted down, overflowing the normal bottom margin for the main text.  I.e. the two become out-of-sync.  In this instance, whitespace was played around with to ensure this would happen (which is why an earlier page was left blank intentionally), but it happened by chance in an earlier draft of this documentation.
% 
% \subsubsection{An inline cprule}
% The |cpruleinline| macro is included to typeset a rule inside the main text without needing to create a full cpruleset environment.  The macro takes one parameter, a |cprulenonum| macro (you could probably use a regular |cprule| macro, but I'm not sure what will happen, except that the rule will probably get a number you could do without).  E.g.
% 
% % \begin{Verbatim}[gobble=1,frame=lines,labelposition=topline,label=Code to produce an inline rule,tabsize=2]
% This is some text before the inline 
% rule \cpruleinline{\cprulenonum{s_i}{LHS}{+/1}{RHS}{s_j}} and 
% this is some text after it.
% \end{Verbatim}
%
% This is some text before the inline 
% rule \cpruleinline{\cprulenonum{s_i}{LHS}{+/1}{RHS}{s_j}} and 
% this is some text after it.
%
% 
% \subsubsection{Sending and receiving}
% Examples are yet to be included.
% 
% \subsubsection{Listings of objects}
% Listing the objects contained within a top-level cP~systems cell is a fairly common activity, especially when writing out examples of the operation of usage for a given system.  Thus, this package includes some assistance for writing those out, also.  The style is derived from that used in other recent papers.
% 
% The procedure is much the same as for a |cpruleset|, in that a |cpobjects| is encapsulated inside a |cpobjectsfloat|.  The former creates the environment and box for the objects to be typeset in, while the latter wraps that in a floating environment that provides floating, captioning and cross-referencing capabilities.  Again borrowing an example from \cite{Cooper2019} (specifically Figure 7), \autoref{obj:fig7} is implemented as:
% 
% \begin{Verbatim}[gobble=1,frame=lines,labelposition=topline,label=Code to produce \autoref{obj:fig7},tabsize=2]
% \begin{cpobjectsfloat}
% 	\begin{cpobjects}
% 		\cpobjectsline{\cpfunc{e}{f(1)~t(2)~w(1)}
% 		\quad \cpfunc{e}{f(1)~t(3)~w(3)}
% 		\quad \cpfunc{e}{f(1)~t(5)~w(2)}
% 		\quad \cpfunc{e}{f(2)~t(1)~w(1)}}
% 		\cpobjectsline{\cpfunc{e}{f(2)~t(4)~w(6)} 
% 		\quad \cpfunc{e}{f(2)~t(5)~w(4)}
% 		\quad \cpfunc{e}{f(3)~t(1)~w(3)}
% 		\quad \cpfunc{e}{f(3)~t(4)~w(8)}}
% 		\cpobjectsline{\cpfunc{e}{f(3)~t(5)~w(5)}
% 		\quad \cpfunc{e}{f(4)~t(2)~w(6)}
% 		\quad \cpfunc{e}{f(4)~t(3)~w(8)} 
% 		\quad \cpfunc{e}{f(4)~t(5)~w(7)}}
% 		\cpobjectsline{\cpfunc{e}{f(5)~t(1)~w(2)} 
% 		\quad \cpfunc{e}{f(5)~t(2)~w(4)}
% 		\quad \cpfunc{e}{f(5)~t(3)~w(5)} 
% 		\quad \cpfunc{e}{f(5)~t(4)~w(7)}}
% 		\cpobjectsline{\cpfunc{v}{v(1)\,v(2)\,v(3)\,v(4)\,v(5)}}
% 	\end{cpobjects}
% 	\caption{\label{obj:fig7} The first example of an objects group}
% \end{cpobjectsfloat}
% \end{Verbatim}
% 
% \begin{cpobjectsfloat}
% 	\begin{cpobjects}
% 		\cpobjectsline{\cpfunc{e}{f(1)~t(2)~w(1)}
% 		\quad \cpfunc{e}{f(1)~t(3)~w(3)}
% 		\quad \cpfunc{e}{f(1)~t(5)~w(2)}
% 		\quad \cpfunc{e}{f(2)~t(1)~w(1)}}
% 		\cpobjectsline{\cpfunc{e}{f(2)~t(4)~w(6)} 
% 		\quad \cpfunc{e}{f(2)~t(5)~w(4)}
% 		\quad \cpfunc{e}{f(3)~t(1)~w(3)}
% 		\quad \cpfunc{e}{f(3)~t(4)~w(8)}}
% 		\cpobjectsline{\cpfunc{e}{f(3)~t(5)~w(5)}
% 		\quad \cpfunc{e}{f(4)~t(2)~w(6)}
% 		\quad \cpfunc{e}{f(4)~t(3)~w(8)} 
% 		\quad \cpfunc{e}{f(4)~t(5)~w(7)}}
% 		\cpobjectsline{\cpfunc{e}{f(5)~t(1)~w(2)} 
% 		\quad \cpfunc{e}{f(5)~t(2)~w(4)}
% 		\quad \cpfunc{e}{f(5)~t(3)~w(5)} 
% 		\quad \cpfunc{e}{f(5)~t(4)~w(7)}}
% 		\cpobjectsline{\cpfunc{v}{v(1)\,v(2)\,v(3)\,v(4)\,v(5)}}
% 	\end{cpobjects}
% 	\caption{\label{obj:fig7} The first example of an objects group}
% \end{cpobjectsfloat}
% 
% It is unclear why the first line in the \autoref{obj:fig7} appears to have a wider space between it and the next line as compared to the following lines -- this has not been observed elsewhere and I can't spot any notable difference between the code for it or any other |cpobjects| environment.  This can be overcome by including a blank |\cpobjectsline{}| at the top of the |cpobjects| environment, but that then leaves a larger gap between the top of the box and the start of the objects.  An explanation and correction of this would be very welcome.
%
%
% \subsubsection{cP terms}
% This example demonstrates the use of the |cpterm| command for stating definitions of the different cP systems terms used in a paper.
% 
% It is strongly recommended that you use a |description| environment in which each of the |cpterm| commands are encapsulated.  Further, heading up the collection with a |paragraph| command for providing a heading seems to be a good idea.  Such an example is shown below, `explaining' some of the symbols that appear in \autoref{rules:TSP2}:
% 
% \begin{Verbatim}[gobble=1,frame=lines,labelposition=topline,label=Code to produce a brief example of the use of cP terms,tabsize=2]
% \paragraph{cP systems terms used}
% \begin{description}
% 		\cpterm{v}{A functor containing very vacuous varieties of vegetables}
% 		\cpterm{s}{A functor containing simply sublime serpentine sausages}
% 		\cpterm{f}{A fiendish \& frightening flash of the fraught folly of including your own full stop.  Except, the behaviour changed and now |\cpterm| no longer puts a `.' at the end of every term, since there were occassions when it would be a bad thing.}
% 		\cpterm{a}{a is for \texttt{atom}.  To quote Radioactive Man:  Up and atom!}
% 		\cpterm{s_1}{The starting state, wherein one states the obvious, subtly}
% \end{description}
% \end{Verbatim}
% 
% \paragraph{cP systems terms used}
% \begin{description}
% 		\cpterm{v}{A functor containing very vacuous varieties of vegetables}
% 		\cpterm{s}{A functor containing simply sublime serpentine sausages}
% 		\cpterm{f}{A fiendish \& frightening flash of the fraught folly of including your own full stop.  Except, the behaviour changed and now \texttt{cpterm} no longer puts a `.' at the end of every term's description, since there were occassions when it would be a bad thing.\texttrademark}
% 		\cpterm{a}{a is for \texttt{atom}.  To quote Radioactive Man:  Up and atom!}
% 		\cpterm{s_1}{The starting state, wherein one states the obvious, subtly}
% \end{description}
% 
% 
% \StopEventually{\PrintIndex}
%
% \section{\label{sec:implementation}Implementation}
% This section presents the actual implementation of the package.  For the most part you probably won't need to refer to it, but every so often you might, especially to work out some error that \LaTeX{} is throwing at you, based on what the commands defined within become once they have been substituted into your document.
%
% \iffalse
%<*package>
% \fi
%
% \iffalse
%
% \fi
% 
% \subsection{Preamble}
%
%    \begin{macrocode}
%

\RequirePackage{array}
\RequirePackage{framed}
\RequirePackage{changepage}
\RequirePackage{amsmath}
\RequirePackage{trimspaces}
\RequirePackage{newfloat}
\RequirePackage{perfectcut}


%    \end{macrocode}
%    
%    \subsection{Environments}
%    
%    \subsubsection{Floats}
%
% \begin{environment}{cprulesetfloat}
% A floating environment inside which |cpruleset| environments are to be placed.  This `wrapping' float provides both the floating capability, as well the ability to caption, label and reference |cprulesets|.
%    \begin{macrocode}
\DeclareFloatingEnvironment[name=Ruleset,
	listname={List of cP~systems Rulesets},within=none]
	{cprulesetfloat}
%    \end{macrocode}
% \end{environment}
%
% \begin{environment}{cpobjectsfloat}
% A floating environment inside which |cpobjects| environments are to be placed.  This `wrapping' float provides both the floating capability, as well the ability to caption, label and reference |cpobjects|.
%    \begin{macrocode}
\DeclareFloatingEnvironment[name=Objects Group,
	listname={List of cP~systems Objects Groups},within=none]
	{cpobjectsfloat}
%    \end{macrocode}
% \end{environment}
% 
% \subsubsection{Maths mode environments}
%
% \begin{environment}{cpruleset}
% A wrapper environment in which |cprules| are listed, and which mimics the usual style of presentation for rules:  A lined box with the rules inside it.
%    \begin{macrocode}
\newenvironment{cpruleset}
	{\begin{framed}\begin{adjustwidth}{-1.0em}{-1.0em}
	\renewcommand{\arraystretch}{1.1}\[\begin{array}{lllllr}}
	{\end{array}\]\end{adjustwidth}\end{framed}
	\setcounter{cpsystems@RuleNumAlt}{\value{cpsystems@RuleNum}}}
%    \end{macrocode}
% \end{environment}
%
% \begin{environment}{cprulesetcontnum}
% Identical to the regular cpruleset environment, except that this one restores the rule number that the previous ruleset had reached.  Use of this environment is \emph{usually} not recommended.
%    \begin{macrocode}
\newenvironment{cprulesetcontnum}
	{\setcounter{cpsystems@RuleNum}{\value{cpsystems@RuleNumAlt}}
	\begin{framed}\begin{adjustwidth}{-1.0em}{-1.0em}
	\renewcommand{\arraystretch}{1.1}\[\begin{array}{lllllr}}
	{\end{array}\]\end{adjustwidth}\end{framed}
	\setcounter{cpsystems@RuleNumAlt}{\value{cpsystems@RuleNum}}}
%    \end{macrocode}
% \end{environment}
%
%
% \begin{environment}{cpobjects}
% A wrapper environment in which |cpobjectline|s are listed, imitating a style used in the past:  A lined box with lines of cP~systems objects defined inside it.  Primarily used for illustrating examples.
%    \begin{macrocode}
\newenvironment{cpobjects}{\begin{framed}}{\end{framed}}
%    \end{macrocode}
% \end{environment}
% 
% \subsection{Macros}
%
% \subsubsection{cP systems definitions}
%
% \begin{macro}{\cptuple}
% A convenience for stating the definition of a cP~system.  The first parameter is the subscript to \(\Pi\), while the next six are T, A, O, R, S, and \(\Bar{s}\).
%    \begin{macrocode}
\newcommand*{\cptuple}[7]{
    \[
        \cpfunc{\Pi_{#1}}{#2, #3, #4, #5, #6, #7}
    \]
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cptupletemplate}
% A convenience for stating the definition of a cP~system.  The template tuple that is usually stated as how a cP~system is defined.
%    \begin{macrocode}
\newcommand*{\cptupletemplate}{
    \cptuple{cP}{T}{A}{O}{R}{S}{\Bar{s}}
}
%    \end{macrocode}
% \end{macro}
%
% 
% \subsubsection{Rules}
% 
% \begin{macro}{\cprule}
% For writing out a rule inside a |cpruleset| environment, as well as displaying and incrementing the rule number.
% Required arguments are, in order, beginning state name; LHS of rule; the label to be applied to the arrow; the ending state name; the RHS of the rule.
% Also can take an optional argument, specifying the measurement of hspace to put in between the RHS and rule number.
%    \begin{macrocode}
\newcommand{\cprule}[6][1.5em]{
    \refstepcounter{cpsystems@RuleNum}
    \cpsystems@basecprule{#2}{#3}{#4}{#5}{#6}
	{\hspace{#1}(\arabic{cpsystems@RuleNum})}
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\cpruleinline}
% For writing out a single rule inside the text, without creating a cpruleset environment.  It still places the rule in its own little paragraph, because it uses the standalone maths environment internally.  Takes a single parameter, a |cprulenonum|.
%    \begin{macrocode}
\newcommand{\cpruleinline}[1]{
	\[\begin{array}{lllllr}#1\end{array}\]
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cprulenonum}
% 	Same as with a regular |\cprule|, but does not show or increment the rule counter.
%    \begin{macrocode}
\newcommand*{\cprulenonum}[5]{
	\cpsystems@basecprule{#1}{#2}{#3}{#4}{#5}{}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cprulecustnum}
% 	Mostly the same as a regular |\cprule|, but takes the rule number to display as an extra parameter.  This also does \emph{not} increment the rule counter.  I'm yet to work out how you could make references to these rule numbers.  This is currently basically just a quick hack to permit the display of alternatives of pre-existing rules, and right now everything must be updated manually.
%    \begin{macrocode}
\newcommand*{\cprulecustnum}[6]{
	\cpsystems@basecprule{#1}{#2}{#3}{#4}{#5}{(#6)}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cppromoter}
% For specifying promoters as part of a rule.
%    \begin{macrocode}
\newcommand*{\cppromoter}[1]{
	\cpsystems@cpprominhi{|}{#1}
}
%    \end{macrocode}
% \end{macro}
% 
%
% \begin{macro}{\cpinhibitor}
% For specifying inhibitors as part of a rule.
%    \begin{macrocode}
\newcommand*{\cpinhibitor}[1]{
	\cpsystems@cpprominhi{\neg}{#1}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cpsend}
% Encapsulate a `send' in cP~systems.
% First argument is the object(s) to be sent, and the second argument is the name of the channel the object(s) shall be sent on.
%    \begin{macrocode}
\newcommand*{\cpsend}[2]{
    \cpsystems@basecpsendrecv{#1}{#2}{!}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cprecv}
% Encapsulate a `receive' in cP~systems.
% First argument is the object(s) to be received, and the second argument is the name of the channel the object(s) shall be received on.
%    \begin{macrocode}
\newcommand*{\cprecv}[2]{
    \cpsystems@basecpsendrecv{#1}{#2}{?}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cpantisend}
% Encapsulate an antiport `send' in cP~systems.
% First argument is the object(s) to be sent, and the second argument is the name of the channel the object(s) shall be sent on.
%    \begin{macrocode}
\newcommand*{\cpantisend}[2]{
    \cpsystems@basecpsendrecv{#1}{#2}{!!}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\cpantirecv}
% Encapsulate an antiport `receive' in cP~systems.
% First argument is the object(s) to be received, and the second argument is the name of the channel the object(s) shall be received on.
%    \begin{macrocode}
\newcommand*{\cpantirecv}[2]{
    \cpsystems@basecpsendrecv{#1}{#2}{??}
}
%    \end{macrocode}
% \end{macro} 
%
%
% % \begin{macro}{\cpchangerulenumber}
% Change the rules counter to whatever positive integer you specify.
% There's likely an upper limit to what numbers you can set (and you may even be able to use negative numbers (you'd have to look into the details of \LaTeX{}/\TeX{}'s counter system to be sure)), but that number has not been found as of yet, and is probably higher than the number of rules you should include in any one paper.
%    \begin{macrocode}
\newcommand*{\cpchangerulenumber}[1]{
	\setcounter{cpsystems@RuleNum}{#1}
	\setcounter{cpsystems@RuleNumAlt}{#1}
}
%    \end{macrocode}
% \end{macro}
% 
% 
% \begin{macro}{\cpresetrulenumber}
% Reset the rules counter, i.e. make it zero again, so that the next rule in the document will receive the number 1.
%    \begin{macrocode}
\newcommand*{\cpresetrulenumber}{
    \cpchangerulenumber{0}
}
%    \end{macrocode}
% \end{macro}
% 
% 
% \begin{macro}{\cponce}
% A minor convenience macro, to typeset the `exactly once' rule mode symbol in the ``correct'' way in rules.
%    \begin{macrocode}
\newcommand*{\cponce}{{\scriptstyle 1}}
%    \end{macrocode}
% \end{macro}
% 
% 
% \begin{macro}{\cpmaxpar}
% A minor convenience macro, to typeset the `maximally parallel' rule mode symbol in the ``correct'' way in rules.
%    \begin{macrocode}
\newcommand*{\cpmaxpar}{{\scriptstyle +}}
%    \end{macrocode}
% \end{macro}
%
%
%
%
% 
% \subsubsection{Objects Groups}
%
%
% \begin{macro}{\cpobjectsline}
% Used for presenting a group of objects, inside a |cpobjects| environment.
%    \begin{macrocode}
\newcommand{\cpobjectsline}[1]{
	\[#1\]
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cpset}
% Used for presenting a list of objects that are meant to be in the same set.  Currently doesn't get used much, might be removed in the future.
%    \begin{macrocode}
\newcommand*{\cpset}[1]{\cpsystems@perfuncurlies{#1}}
%    \end{macrocode}
% \end{macro}
%
% 
% \subsubsection{Miscellaneous}
%
% \begin{macro}{\cpfunc}
% Command for declaring a cP~systems functor.
% The first argument is the symbol for the functor itself, and the second argument is the objects contained inside the functor.
%    \begin{macrocode}
\newcommand*{\cpfunc}[2]{
	\trim@spaces@noexp{#1\cpsystems@perfunparens{#2}}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cpfuncms}
% Command for declaring a cP~systems functor \emph{which uses micro-surgeries}.
% The first argument is the symbol for the functor itself, and the second argument is the objects contained inside the functor.
% Currently the only difference between this and the |cpfunc| command is the nature of the brackets used -- regular |cpfunc|s use parentheses, while micro-surgery functors use curly braces.  Both (but especially the latter) are potentially subject to change in the future.  Thus, one of the reasons why it is recommended to use these commands is that it will be much easier to change all your micro-surgery functors in future if the style changes.  Another reason is that these play nicely with the regular |cpfunc|s to give you automatically growing brackets.
%    \begin{macrocode}
\newcommand*{\cpfuncms}[2]{
	\trim@spaces@noexp{#1\cpsystems@perfuncurlies{#2}}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cpfuncn}
% Command for declaring a three-level cP~systems indexed functor.
% The first argument is the symbol for the functor itself, the second argument is the objects contained inside the first part of the term, and the third argument the bit contained inside the last term.
%    \begin{macrocode}
\newcommand*{\cpfuncn}[3]{
	\cpfunc{#1}{#2}\cpsystems@perfunparens{#3}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cpfuncnms}
% Command for declaring a three-level cP~systems indexed functor with a micro-surgery on the end part.
% The first argument is the symbol for the functor itself, the second argument is the objects contained inside the first part of the term, and the third argument the bit contained inside the last term, which is the micro-surgical part.
%    \begin{macrocode}
\newcommand*{\cpfuncnms}[3]{
	\cpfunc{#1}{#2}\cpsystems@perfuncurlies{#3}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cpfuncnn}
% Command for declaring a four-level cP~systems indexed functor.
% The first argument is the symbol for the functor itself, the second argument is the objects contained inside the first part of the term, the third argument the bit contained inside next part, and the fourth the bit contained in the last part of the term.
%    \begin{macrocode}
\newcommand*{\cpfuncnn}[4]{
	\cpfuncn{#1}{#2}{#3}\cpsystems@perfunparens{#4}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cpfuncnnms}
% Command for declaring a three-level cP~systems indexed functor with a micro-surgery on the end part.
% The first argument is the symbol for the functor itself, the second argument is the objects contained inside the first part of the term, the third argument the bit contained inside next part, and the fourth the bit contained in the last part of the term, which is the micro-surgical part.
%    \begin{macrocode}
\newcommand*{\cpfuncnnms}[4]{
	\cpfuncn{#1}{#2}{#3}\cpsystems@perfuncurlies{#4}
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\cpterm}
% Used when writing a listing describing the cP systems terms used in a given text (which is envisaged to be something that occurs immediately after stating the ruleset).  The general suggestion is to use these inside a |description| environment, which tends to leave the whole thing quite nicely set out.  The end result is the symbols in math mode, and then their descriptions next to them.
%    \begin{macrocode}
\newcommand*{\cpterm}[2]{
	\item[$#1$]#2
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cpundig}
% A parameter-less convenience macro for inserting the correctly-formatted cP~systems `unitary digit' in rules.
%    \begin{macrocode}
\newcommand*{\cpundig}{\mathit{1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cpempty}
% A parameter-less convenience macro for inserting the correctly-formatted empty functor symbol (which is actually just a |\lambda|).  Mostly used so that intent is clear in the rules specifications, but also partly in case someone ends up changing how empty functors are specified.
%    \begin{macrocode}
\newcommand*{\cpempty}{\lambda}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cpdiscard}
% A minor convenience macro, to typeset the `discard/don't care' symbol used in cP~systems in the ``correct'' way in rules.  Honestly, in this instance the underlying command is much shorter, but this is thought of as slightly `safer' (it's quite easy to muck things up with the underscore), communicates intent better, and moreover use of this makes it much easier to change to using a different symbol if desired.
%    \begin{macrocode}
\newcommand*{\cpdiscard}{\_}
%    \end{macrocode}
% \end{macro}
% 
%
% 
% \subsection{Internal}
% Macros that are only intended to be used inside the package, and probably shouldn't be used outside of it.  Much as if the previous macros are all the public interface of the package, while these ones are the private implementation details.
%
%
% \subsubsection{Counters}
% A couple of counters used for tracking rules numbers.
%    \begin{macrocode}
	\newcounter{cpsystems@RuleNum}[cprulesetfloat]
	\newcounter{cpsystems@RuleNumAlt}
%    \end{macrocode}
% 
% \begin{macro}{\cpsystems@basecprule}
% For writing out rules inside a |cpruleset| environment.
% Required arguments are, in order, beginning state name; LHS of rule; the label to be applied to the arrow; the ending state name; the RHS of the rule.
%    \begin{macrocode}
\newcommand{\cpsystems@basecprule}[6]{
    \trim@spaces@noexp{#1 & #2 & \rightarrow_{#3} & #4 & #5 	& #6\\}
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\cpsystems@cpprominhi}
% For writing out promoters and inhibitors in a |cpruleset| environment.
%    \begin{macrocode}
\newcommand{\cpsystems@cpprominhi}[2]{
    \trim@spaces@noexp{& & & & ~ \hspace{1em} ~ #1 ~ #2 & \\}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cpsystems@basecpsendrecv}
% Base rule which both |\cpsend| and |\cprecv| make use of.  This is a ``single source of truth'', and means only one place needs to be changed to change the brackets which encapsulate messages.
%    \begin{macrocode}
\newcommand{\cpsystems@basecpsendrecv}[3]{
    \trim@spaces@noexp{\cpsystems@perfuncurlies{#1}{#3}_{#2}}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cpsystems@perfunparens}
% Convencience rule used to provide the wrapping of other things in auto-growing parentheses.  Introduced because I found I was starting to copy-paste the raw command frequently.
%    \begin{macrocode}
\newcommand{\cpsystems@perfunparens}[1]{
    \trim@spaces@noexp{\perfectunary{IncreaseHeight}{(}{)}{#1}}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cpsystems@perfuncurlies}
% Convencience rule used to provide the wrapping of other things in auto-growing curly braces.  Introduced because I found I was starting to copy-paste the raw command frequently.
%    \begin{macrocode}
\newcommand{\cpsystems@perfuncurlies}[1]{
    \trim@spaces@noexp{\perfectunary{IncreaseHeight}{\{}{\}}{#1}}
}
%    \end{macrocode}
% \end{macro}
%
% \section{Possible improvements}
% A handful of possible improvements have been thought of already, though in most cases it is entirely unclear how to achieve them at this point.  They include:
% \begin{itemize}
% \item A command to create line breaks in |cpruleset| environments, without requiring the user to fill in all the \&s required by the contained |array| environment to make it work.
% \item Restoring support for line breaks inside |cpfunc| commands -- it seems to be unavoidable at times, but doesn't play nicely with the resizing brackets.
% \item Change to a different, more modern way of declaring |cpruleset| environments that doesn't rely on the |array| environment.  There's nothing wrong with |array|, but it's probably more low-level that I actually need, and doesn't come with some conveniences (I imagine).
% \item A way to use cross-references to refer to rule numbers in the rulesets.
% \item The ability to specify optional parameters to the |cpruleset| stating the desired amount of arraystretch and adjustwidth  to use.  Currently they are hard-coded as \texttt{1.1em} \texttt{-1.0em}, respectively.
% \item Provide the ability to specify a printed name for |cprulesetfloat| and |cpobjectsfloat| besides `Ruleset' and `Objects Group'.
% \item Make the package available via CTAN.
% \item Eliminate the extraneous symbols in the index (it is unclear why they are appearing, when they have been specifically excluded using the normal method for \texttt{.dtx} files).
% \item Change the implementation of the package to using \LaTeX{}3's approach.
% \item Versions of |cpruleset| and |cpobjects| that \emph{don't} draw boxes around themselves.  Perhaps, e.g. |cpruleset*|.
% \item A way to break up one ruleset or objects group into multiple boxes and/or across multiple pages, cleanly.  Though, to be honest, if this is becoming an issue for a ruleset, it probably means that the ruleset has grown large enough that it could be logically split into subsets.  Objects groups may be a different story.
% \item Seek to integrate this package into David Orellana Martín's `membranecomputing' package (\url{https://ctan.org/pkg/membranecomputing}).
% \item Modify the objectsgroup environment to show somehow the state that the system or containing top-level cell is in at the moment of the object snapshot.
% \item Use the indexing function properly, so that it appears in the table of contents, and also includes all the various types of numbers pointing to different things that it talks about in its preamble.
% \end{itemize}
% 
% Note that there is absolutely no time-frame currently for the completion of any of these, and at least two of them are probably in conflict with each other.
% 
% \bibliographystyle{acm}
% \bibliography{cpsystems}
%
% \iffalse
%</package>
% \fi
%
% \Finale
% 
